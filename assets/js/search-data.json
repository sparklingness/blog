{
  
    
        "post0": {
            "title": "Bert Notebook Blog Post(2)",
            "content": "ref: http://mccormickml.com/2019/05/14/BERT-word-embeddings-tutorial/ . 1. Loading Pre-Trained BERT . ! pip install pytorch-pretrained-bert . Collecting pytorch-pretrained-bert Downloading https://files.pythonhosted.org/packages/d7/e0/c08d5553b89973d9a240605b9c12404bcf8227590de62bae27acbcfe076b/pytorch_pretrained_bert-0.6.2-py3-none-any.whl (123kB) |████████████████████████████████| 133kB 2.8MB/s Requirement already satisfied: numpy in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (1.18.2) Requirement already satisfied: boto3 in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (1.12.38) Requirement already satisfied: torch&gt;=0.4.1 in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (1.4.0) Requirement already satisfied: regex in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (2019.12.20) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (4.38.0) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from pytorch-pretrained-bert) (2.21.0) Requirement already satisfied: jmespath&lt;1.0.0,&gt;=0.7.1 in /usr/local/lib/python3.6/dist-packages (from boto3-&gt;pytorch-pretrained-bert) (0.9.5) Requirement already satisfied: botocore&lt;1.16.0,&gt;=1.15.38 in /usr/local/lib/python3.6/dist-packages (from boto3-&gt;pytorch-pretrained-bert) (1.15.38) Requirement already satisfied: s3transfer&lt;0.4.0,&gt;=0.3.0 in /usr/local/lib/python3.6/dist-packages (from boto3-&gt;pytorch-pretrained-bert) (0.3.3) Requirement already satisfied: urllib3&lt;1.25,&gt;=1.21.1 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;pytorch-pretrained-bert) (1.24.3) Requirement already satisfied: idna&lt;2.9,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;pytorch-pretrained-bert) (2.8) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;pytorch-pretrained-bert) (2020.4.5.1) Requirement already satisfied: chardet&lt;3.1.0,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;pytorch-pretrained-bert) (3.0.4) Requirement already satisfied: python-dateutil&lt;3.0.0,&gt;=2.1 in /usr/local/lib/python3.6/dist-packages (from botocore&lt;1.16.0,&gt;=1.15.38-&gt;boto3-&gt;pytorch-pretrained-bert) (2.8.1) Requirement already satisfied: docutils&lt;0.16,&gt;=0.10 in /usr/local/lib/python3.6/dist-packages (from botocore&lt;1.16.0,&gt;=1.15.38-&gt;boto3-&gt;pytorch-pretrained-bert) (0.15.2) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.6/dist-packages (from python-dateutil&lt;3.0.0,&gt;=2.1-&gt;botocore&lt;1.16.0,&gt;=1.15.38-&gt;boto3-&gt;pytorch-pretrained-bert) (1.12.0) Installing collected packages: pytorch-pretrained-bert Successfully installed pytorch-pretrained-bert-0.6.2 . import torch from pytorch_pretrained_bert import BertTokenizer, BertModel, BertForMaskedLM # OPTIONAL: if you want to have more information on what&#39;s happening, activate the logger as follows import logging # logging.basicConfig(level=logging.INFO) import matplotlib.pyplot as plt % matplotlib inline # Load pre-trained model tokenizer (vocabulary) tokenizer = BertTokenizer.from_pretrained(&#39;bert-base-uncased&#39;) . 100%|██████████| 231508/231508 [00:00&lt;00:00, 315280.35B/s] . 2. Input Formatting . 2.1. Special Tokens . Special tokens to mark the beginning ([CLS]) and seprataion/end of sentences ([SEP]) . BERT can take as input either one or two sentences, and expects special tokens to mark the beginning and end of each one: . 2 Sentence Input: . [CLS] The man wnent to the store. [SEP] He bought a gallon of milk. [SEP] . 1 Sentence Input: . [CLS] The man went to the store. [SEP] . 2.2. Tokenization . text = &quot;Here is the sentence I want embeddings for.&quot; marked_text = &quot;[CLS] &quot; + text + &quot; [SEP]&quot; # Tokenize our sentence with the BERT tokenizer. tokenized_text = tokenizer.tokenize(marked_text) # Print out the tokens. print(tokenized_text) . [&#39;[CLS]&#39;, &#39;here&#39;, &#39;is&#39;, &#39;the&#39;, &#39;sentence&#39;, &#39;i&#39;, &#39;want&#39;, &#39;em&#39;, &#39;##bed&#39;, &#39;##ding&#39;, &#39;##s&#39;, &#39;for&#39;, &#39;.&#39;, &#39;[SEP]&#39;] . # Define a new example sentence with multiple meanings of the word &quot;bank&quot; text = &quot;After stealing money from the bank vault, the bank robber was seen fishing on the Mississippi river bank.&quot; # Add the special tokens. marked_text = &quot;[CLS] &quot; + text + &quot; [SEP]&quot; # Split the sentence into tokens. tokenized_text = tokenizer.tokenize(marked_text) # Map the token strings to their vocabulary indeces. indexed_tokens = tokenizer.convert_tokens_to_ids(tokenized_text) # Display the words with their indeces. for tup in zip(tokenized_text, indexed_tokens): print(&#39;{:&lt;12} {:&gt;6,}&#39;.format(tup[0], tup[1])) . [CLS] 101 after 2,044 stealing 11,065 money 2,769 from 2,013 the 1,996 bank 2,924 vault 11,632 , 1,010 the 1,996 bank 2,924 robber 27,307 was 2,001 seen 2,464 fishing 5,645 on 2,006 the 1,996 mississippi 5,900 river 2,314 bank 2,924 . 1,012 [SEP] 102 . 2.3. Segment ID . # Mark each of the 22 tokens as belonging to sentence &quot;1&quot;. segments_ids = [1] * len(tokenized_text) print(segments_ids) . [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] . 3. Extracting Embeddings . 3.1. Running BERT on our text . model.eval() evaluation mode turns off dropout regularization which is used in training . # Convert inputs to PyTorch tensors tokens_tensor = torch.tensor([indexed_tokens]) print(tokens_tensor) segments_tensors = torch.tensor([segments_ids]) # Load pre-trained model (weights) model = BertModel.from_pretrained(&#39;bert-base-uncased&#39;) # Put the model in &quot;evaluation&quot; mode, meaning feed-forward operation. model.eval() . tensor([[ 101, 2044, 11065, 2769, 2013, 1996, 2924, 11632, 1010, 1996, 2924, 27307, 2001, 2464, 5645, 2006, 1996, 5900, 2314, 2924, 1012, 102]]) . 100%|██████████| 407873900/407873900 [00:35&lt;00:00, 11382845.79B/s] . BertModel( (embeddings): BertEmbeddings( (word_embeddings): Embedding(30522, 768, padding_idx=0) (position_embeddings): Embedding(512, 768) (token_type_embeddings): Embedding(2, 768) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) (encoder): BertEncoder( (layer): ModuleList( (0): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (1): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (2): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (3): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (4): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (5): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (6): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (7): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (8): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (9): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (10): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (11): BertLayer( (attention): BertAttention( (self): BertSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): BertLayerNorm() (dropout): Dropout(p=0.1, inplace=False) ) ) ) ) (pooler): BertPooler( (dense): Linear(in_features=768, out_features=768, bias=True) (activation): Tanh() ) ) . torch.no_grad deactivates the gradient calculations, saves memory, and speeds up computation. (we don&#39;t need gradients or backpropagation since we&#39;re just running a forward pass). . # Predict hidden states features for each layer with torch.no_grad(): encoded_layers, _ = model(tokens_tensor, segments_tensors) . 3.2. Understanding the Output . print(&quot;Number of layers:&quot;, len(encoded_layers)) layer_i = 0 print(&quot;Number of batches:&quot;, len(encoded_layers[layer_i])) batch_i = 0 print(&quot;Number of tokens:&quot;, len(encoded_layers[layer_i][batch_i])) token_i = 0 print(&quot;Number of hidden units:&quot;, len(encoded_layers[layer_i][batch_i][token_i])) . Number of layers: 12 Number of batches: 1 Number of tokens: 22 Number of hidden units: 768 . # For the 5th token in our sentence, select its feature values from layer 5. token_i = 5 layer_i = 5 vec = encoded_layers[layer_i][batch_i][token_i] # Plot the values as a histogram to show their distribution. plt.figure(figsize=(10,10)) plt.hist(vec, bins=200) plt.show() . # `encoded_layers` is a Python list. print(&#39; Type of encoded_layers: &#39;, type(encoded_layers), len(encoded_layers)) # Each layer in the list is a torch tensor. print(&#39;Tensor shape for each layer: &#39;, encoded_layers[0].size()) . Type of encoded_layers: &lt;class &#39;list&#39;&gt; 12 Tensor shape for each layer: torch.Size([1, 22, 768]) . # Concatenate the tensors for all layers. We use `stack` here to # create a new dimension in the tensor. token_embeddings = torch.stack(encoded_layers, dim=0) token_embeddings.size() . torch.Size([12, 1, 22, 768]) . # Remove dimension 1, the &quot;batches&quot;. token_embeddings = torch.squeeze(token_embeddings, dim=1) token_embeddings.size() . torch.Size([12, 22, 768]) . # Swap dimensions 0 and 1. token_embeddings = token_embeddings.permute(1, 0, 2) token_embeddings.size() . torch.Size([22, 12, 768]) . 3.3. Creating word and sentence vectors from hidden states . Word Vectors . # Stores the token vectors, with shape [22 x 3,072] (4 x 768 = 3,072) token_vecs_cat = [] # `token_embeddings` is a [22 x 12 x 768] tensor. # For each token in the sentence... for token in token_embeddings: # `token` is a [12 x 768] tensor # Concatenate the vectors (that is, append them together) from the last four layers. # Each layer vector is 768 values, so `cat_vec` is length 3,072. cat_vec = torch.cat((token[-1], token[-2], token[-3], token[-4]), dim=0) # Use `cat_vec` to represent `token`. token_vecs_cat.append(cat_vec) print(&#39;Shape is: %d x %d&#39; % (len(token_vecs_cat), len(token_vecs_cat[0]))) . Shape is: 22 x 3072 . # Stores the token vectors, with shape [22 x 768] token_vecs_sum = [] # `token_embeddings` is a [22 x 12 x 768] tensor. # For each token in the sentence... for token in token_embeddings: # `token` is a [12 x 768] tensor # Sum the vectors from the last four layers. sum_vec = torch.sum(token[-4:], dim=0) # Use `sum_vec` to represent `token`. token_vecs_sum.append(sum_vec) print(&#39;Shape is: %d x %d&#39; % (len(token_vecs_sum), len(token_vecs_sum[0]))) . Shape is: 22 x 768 . Sentence Vectors . # `encoded_layers` has shape [12 x 1 x 22 x 768] # `token_vecs` is a tensor with shape [22 x 768] token_vecs = encoded_layers[11][0] # Calculate the average of all 22 token vectors. sentence_embedding = torch.mean(token_vecs, dim=0) . print(&quot;Our final sentence embedding vector of shape:&quot;, sentence_embedding.size()) . Our final sentence embedding vector of shape: torch.Size([768]) . 3.4. Confirming contextually dependent vectors . for i, token_str in enumerate(tokenized_text): print(i, token_str) . 0 [CLS] 1 after 2 stealing 3 money 4 from 5 the 6 bank 7 vault 8 , 9 the 10 bank 11 robber 12 was 13 seen 14 fishing 15 on 16 the 17 mississippi 18 river 19 bank 20 . 21 [SEP] . print(&#39;First 5 vector values for each instance of &quot;bank&quot;.&#39;) print(&#39;&#39;) print(&quot;bank vault &quot;, str(token_vecs_sum[6][:5])) print(&quot;bank robber &quot;, str(token_vecs_sum[10][:5])) print(&quot;river bank &quot;, str(token_vecs_sum[19][:5])) . First 5 vector values for each instance of &#34;bank&#34;. bank vault tensor([ 2.1319, -2.1413, -1.6260, 0.8638, 3.3173]) bank robber tensor([ 1.1868, -1.5298, -1.3770, 1.0648, 3.1446]) river bank tensor([ 1.1295, -1.4725, -0.7296, -0.0901, 2.4970]) . from scipy.spatial.distance import cosine # Calculate the cosine similarity between the word bank # in &quot;bank robber&quot; vs &quot;river bank&quot; (different meanings). diff_bank = 1 - cosine(token_vecs_sum[10], token_vecs_sum[19]) # Calculate the cosine similarity between the word bank # in &quot;bank robber&quot; vs &quot;bank vault&quot; (same meaning). same_bank = 1 - cosine(token_vecs_sum[10], token_vecs_sum[6]) print(&#39;Vector similarity for *similar* meanings: %.2f&#39; % same_bank) print(&#39;Vector similarity for *different* meanings: %.2f&#39; % diff_bank) . Vector similarity for *similar* meanings: 0.95 Vector similarity for *different* meanings: 0.68 .",
            "url": "https://sparklingness.github.io/blog/bert/jupyter/2020/04/11/Bert-Word-Embedding-Tutorial.html",
            "relUrl": "/bert/jupyter/2020/04/11/Bert-Word-Embedding-Tutorial.html",
            "date": " • Apr 11, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Bert Notebook Blog Post",
            "content": "",
            "url": "https://sparklingness.github.io/blog/bert/jupyter/2020/03/29/Inspect-Bert-Vocabulary.html",
            "relUrl": "/bert/jupyter/2020/03/29/Inspect-Bert-Vocabulary.html",
            "date": " • Mar 29, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://sparklingness.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

}